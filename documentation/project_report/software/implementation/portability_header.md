Portability Header
=================

With the addition of device abstraction, I have decided to even abstract pin hardware as well. By stripping the port pointer dereference in Atmel's avr/io.h file, we enable storage of useful memory locations such as ports and their corresponding modifiers.

``
Port PORT[] = {
        {(vbyte *)_PINA,(vbyte *)_PORTA,(vbyte *)_DDRA},
        {(vbyte *)_PINB,(vbyte *)_PORTB,(vbyte *)_DDRB},
        {(vbyte *)_PINC,(vbyte *)_PORTC,(vbyte *)_DDRC},
        {(vbyte *)_PIND,(vbyte *)_PORTD,(vbyte *)_DDRD},
}

	\#define PA &PORT[0]
	\#define PA0 &PA_PIN[0]
	\#define PA1 &PA_PIN[1]
...
``

Now that ports and pins are storable, we can associate our device structures with pins using pointers. An easy way to keep track of a boards implementation is to write a pin header file that maps symbolic names to actual pins. This allows us to easily maintain a software for a number of different hardware implementations.

``
	\#define y_step PA0
	\#define x_dir PA1
	\#define motor_enb PA2
	\#define x_step PA3
	\#define x_stop PA4
	\#define y_stop PA5
	\#define b_temp PA6
	\#define e_temp PA7
``

Furthermore, this method enables us to write portable C code. Multiple architectures can be handled by simply swapping out the pin.c file. It contains all the necessary architecture interaction. Machine code for MSP430, ATmega and ARM could be generated by the 'same' piece of code. The software can be written without being too concerned with the current architecture.

``
void pin_low(Pin *pin){
                *pin->port_ptr->out &= ~pin->mask;
}
``

For a fully cross compatible framework timers and interrupts need to be implemented in a similar method. This is definitely possible but out of this projects scope.
